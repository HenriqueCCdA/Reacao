#include<Edo.h>

/*********************************************************************
 * Data de criacao    : 16/06/2019                                   *
 * Data de modificaco : 00/00/0000                                   *
 * ------------------------------------------------------------------*
 * rtk4 :  Metodo Runge-kutta explicito de 4 ° ordem                 *
 * ------------------------------------------------------------------*
 * Parametros de entrada:                                            *
 * ------------------------------------------------------------------* 
 * y     -> valores inicial                                          * 
 * param -> paramatros utilizado no calculo da funcao f              *
 * x1    -> limite inferio do intervalo de integracao                *
 * x2    -> limite superior do intervalo de integraçao               *
 * hInit -> passo inicial                                            *
 * maxIt -> numero maximo de iteração no processo de integracao      *
 * nEdo  -> numero de edos                                           *
 * ------------------------------------------------------------------*
 * Paramanetros de saida:                                            *
 * ------------------------------------------------------------------*
 * ------------------------------------------------------------------*
 * *******************************************************************/
void rtk4(DOUBLE *y            , DOUBLE *param
         ,DOUBLE const x1      , DOUBLE const x2
         ,DOUBLE const hInit
         ,INT const maxIt     , short const nEdo
         ,short const outCod  , void (*rhs)())
{
  FILE *file=NULL;
  short i;
  INT it;
  DOUBLE h,*k1,*k2,*k3,*k4,*f,*yt;
  DOUBLE x=x1,hh,xh,h6;
 
  if(outCod == FILE_OUT)
    file = openFile("output.out","w");

  k1   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k1,"k1");
  k2   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k2,"k2");
  k3   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k3,"k3");
  k4   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k4,"k4");
  f    = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(f,"f");
  yt   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(yt,"yt");
  h6 = 1.e0/6.e0;  
  h  = hInit;
  hh = 0.5e0*h;
  xh = x+hh;
  it = 0;
  do{
    
/*... k1*/
    rhs(x,y,f,param);
    for(i=0;i<nEdo;i++)
    {
      k1[i] = h*f[i];
      yt[i] = y[i] + hh*f[i];
    }
/*.....................................................................*/

/*... k2*/
    rhs(xh,yt,f,param);
    for(i=0;i<nEdo;i++)
    {
      k2[i] = h*f[i];   
      yt[i] = y[i] + hh*f[i];
    }

/*.....................................................................*/

/*... k3*/
    rhs(xh,yt,f,param);
    for(i=0;i<nEdo;i++)
    {
      k3[i] = h*f[i]; 
      yt[i] = y[i] + h*f[i];;  
    }
/*.....................................................................*/
 
/*... k4*/
    rhs(x+h,yt,f,param);
    for(i=0;i<nEdo;i++)
    {
      k4[i] = h*f[i];   
    }
/*.....................................................................*/

/*...*/
    for(i=0;i<nEdo;i++)
      y[i] += h6*(k1[i] + 2.0e0*(k2[i] + k3[i]) + k4[i]); 
/*.....................................................................*/

/*...*/
     writeOutput(it            , x
                ,h             , y
                ,nEdo          , outCod
                ,file);
/*.....................................................................*/

/*...*/
    it++;
    x+=h;
/*.....................................................................*/
  }while( x <= x2  && it < maxIt);
/*.....................................................................*/

/*...*/
  free(yt);
  free(f);
  free(k4);
  free(k3);
  free(k2);
  free(k1);
/*.....................................................................*/

  fclose(file);
}
/*********************************************************************
 * Data de criacao    : 16/06/2019                                   *
 * Data de modificaco : 00/00/0000                                   *
 * ------------------------------------------------------------------*
 * stepperDopr5 :  Metodo Runge-kutta explicito de 5 ° ordem como    *
 * passo adaptativo                                                  *
 * ------------------------------------------------------------------*
 * Parametros de entrada:                                            *
 * ------------------------------------------------------------------* 
 * y     -> valores inicial                                          * 
 * param -> paramatros utilizado no calculo da funcao f              *
 * x1    -> limite inferio do intervalo de integracao                *
 * x2    -> limite superior do intervalo de integraçao               *
 * aTol  -> precisao absoluta                                        *
 * rTol  -> precisao relativa                                        *
 * hInit -> passo inicial                                            *
 * maxIt -> numero maximo de iteração no processo de integracao      *
 * nEdo  -> numero de edos                                           *
 * ------------------------------------------------------------------*
 * Paramanetros de saida:                                            *
 * ------------------------------------------------------------------*
 * ------------------------------------------------------------------*
 * *******************************************************************/
int stepperDopr5(DOUBLE *y                  ,DOUBLE *param
                 ,DOUBLE const x1           ,DOUBLE const x2
                 ,DOUBLE const aTol         ,DOUBLE const rTol
                 ,DOUBLE const hInit        ,short const nEdo
                 ,unsigned INT const maxInt , bool const fStopIt    
                 ,short const outCod        , const char *const fName 
                 ,void (*rhs)())
{
  FILE *file=NULL;
  short i, iChangeSteps,maxChangeSteps;
  bool lastReject;
  unsigned INT it,IntegralStepMax;
  INT order;
  DOUBLE a[21],b[7],bi[7],c[7],e[7];
  DOUBLE h,*k1,*k2,*k3,*k4,*k5,*k6,*f,*yt;
  DOUBLE x,scale,delta,err,errOld,safe,hNew
      ,maxScale,minScale,alfa,beta;
 
  if(outCod == FILE_OUT)
    file = openFile(fName ,"w");
/*...*/
  IntegralStepMax = maxInt;
  safe            = 0.9e0;
  maxScale        = 10.e0;
  minScale        = 0.2e0;  
  order           = 5;
  beta            = 0.4/order;
  alfa            = 1.e0/order - 0.75*beta;
/*...................................................................*/

/*... Dormand-Prince 5*/
/*...*/
  b[0]  = 35.0/384.0;
  b[1]  = 0.0;
  b[2]  = 500.0/1113.0;
  b[3]  = 125.0/192.0; 
  b[4]  =-2187.0/6784.0;
  b[5]  = 11.0/84.0;
  b[6]  = 0.e0;
/*...*/
  bi[0]  = 5179.0/57600.0;
  bi[1]  = 0.0;
  bi[2]  = 7571.0/16695.0;
  bi[3]  = 393.0/640.0; 
  bi[4]  =-92097.0/339200.0;
  bi[5]  = 187.0/2100.0;
  bi[6]  = 0.025e0;
/*...*/
  a[ 0] =     0.2;        /*a21*/
  a[ 1] =     3.0/40.0;        /*a31*/
  a[ 2] =     9.0/40.0;        /*a32*/
  a[ 3] =    44.0/45.0;        /*a41*/
  a[ 4] =   -56.0/15.0;        /*a42*/
  a[ 5] =    32.0/9.0;         /*a43*/
  a[ 6] = 19372.0/6561.0;      /*a51*/
  a[ 7] =-25360.0/2187.0;      /*a52*/
  a[ 8] =   64448.0/6561.0;    /*a53*/
  a[ 9] =     212.0/729.0;     /*a54*/
  a[10] =    9017.0/3168.0;    /*a61*/
  a[11] =    -355.0/33.0;      /*a62*/
  a[12] =   46732.0/5247.0;    /*a63*/
  a[13] =      46.0/176.0;     /*a64*/
  a[14] =   -5103.0/18656.0;   /*a65*/
  a[15] = b[0];                /*a71*/
  a[16] = b[1];                /*a72*/
  a[17] = b[2];                /*a73*/
  a[18] = b[3];                /*a74*/
  a[19] = b[4];                /*a75*/
  a[20] = b[5];                /*a76*/

/*...*/
  c[0]  = 0.0;
  c[1]  = 0.2;
  c[2]  = 0.3;
  c[3]  = 0.8; 
  c[4]  = 8.0/9.0;
  c[5]  = 1.0;
  c[6]  = 1.0;
/*...*/
  for(i=0;i<7;i++)
    e[i] = b[i] - bi[i];
/*...*/
  k1   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k1,"k1");
  k2   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k2,"k2");
  k3   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k3,"k3");
  k4   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k4,"k4");
  k5   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k5,"k5");
  k6   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k6,"k6");
  f    = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(f,"f");
  yt   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(yt,"yt");
/*...................................................................*/

/*...*/
  h              = hInit;
  it             = 0;
  x              = x1;
  errOld         = 1.e0;
  maxChangeSteps = 10;
/*...................................................................*/

/*...*/
  do
  {
    lastReject   = false;
    iChangeSteps = 0;
    do
    {
/*... k1 - a[0] - a21*/
      rhs(x,y,f,param);
      for(i=0;i<nEdo;i++)
      {
        k1[i] = h*f[i];
        yt[i] = y[i] + a[0]*k1[i];
      }
/*.....................................................................*/

/*... k2 - a[1-2] - a31, a32 */
      rhs(x+c[1]*h,yt,f,param);
      for(i=0;i<nEdo;i++)
      {
        k2[i] = h*f[i];   
        yt[i] = y[i] + a[1]*k1[i] + a[2]*k2[i];
      }
/*.....................................................................*/

/*... k3 - a[3-5] - a41, a42, a43 */
      rhs(x+c[2]*h,yt,f,param);
      for(i=0;i<nEdo;i++)
      {
        k3[i] = h*f[i]; 
        yt[i] = y[i] + a[3]*k1[i] + a[4]*k2[i] + a[5]*k3[i];  
      }
/*.....................................................................*/
 
/*... k4 - a[6-9] - a51, a52, a53, a54 */
      rhs(x+c[3]*h,yt,f,param);
      for(i=0;i<nEdo;i++)
      {
        k4[i] = h*f[i]; 
        yt[i] = y[i] + a[6]*k1[i] + a[7]*k2[i] + a[8]*k3[i] + a[9]*k4[i];
      }
/*.....................................................................*/

/*... k5 - a[10-14] - a61, a62, a63, a64, a65 */
      rhs(x+c[4]*h,yt,f,param);
      for(i=0;i<nEdo;i++)
      {
        k5[i] = h*f[i]; 
        yt[i] = y[i] + a[10]*k1[i] + a[11]*k2[i] + a[12]*k3[i] + a[13]*k4[i] 
              + a[14]*k5[i];  
      }
/*.....................................................................*/

/*... k6*/
      rhs(x+c[5]*h,yt,f,param);
      for(i=0;i<nEdo;i++)
        k6[i] = h*f[i]; 
/*.....................................................................*/

/*...*/
     for(i=0;i<nEdo;i++)
      {
        yt[i] = y[i] + b[0]*k1[i] + b[1]*k2[i] + b[2]*k3[i] + b[3]*k4[i] 
              + b[4]*k5[i] + b[5]*k6[i];  
      }
/*.....................................................................*/


/*...*/
      rhs(x+h,yt,f,param);
      for(i=0,err=0.e0;i<nEdo;i++)
      {
        scale = aTol + max(fabs(y[i]),fabs(yt[i]))*rTol;
        delta = e[0]*k1[i] + e[1]*k2[i] + e[2]*k3[i] + e[3]*k4[i]
              + e[4]*k5[i] + e[5]*k6[i] + h*e[6]*f[i];
        err+=  (delta/scale)*(delta/scale);
      }
      err = sqrt(err/nEdo);  
/*... passou no controle de erro de trucamento*/
      if( err <= 1.0)
      {
/*...*/
        if(err==0.0)
          scale = maxScale;
        else
        {
          scale =safe*pow(err,-alfa)*pow(errOld,beta);
/*... minScale < hNew/h < maxscale*/
          if( scale > maxScale)
            scale = maxScale;
          else if(scale < minScale)
            scale = minScale;
          }
/*.....................................................................*/

/*... */
          if(lastReject)
            hNew = h*min(scale,1.0);
          else
            hNew = h*scale;
/*.....................................................................*/

          errOld = max(err,1.0e-4);        
          lastReject = false;        
          break;
      }
/*.....................................................................*/

/*...*/
      lastReject = true; 
      scale=max(safe*pow(err,-alfa),minScale);
      h*=scale;
/*.....................................................................*/
      iChangeSteps++;
/*.....................................................................*/
    }while(iChangeSteps < maxChangeSteps);
/*.....................................................................*/

/*...*/
    if(iChangeSteps == maxChangeSteps)
    {
      printf("Numero maximo de mudanca de passo alcancada!!\n");
      exit(EXIT_FAILURE);
    }
/*...................................................................*/

/*...*/
    for(i=0;i<nEdo;i++)
      y[i] = yt[i];
/*.....................................................................*/

/*...*/
     writeOutput(it            , x
                ,h             , y
                ,nEdo          , outCod
                ,file);
/*.....................................................................*/

/*...*/
    it++;
    if ( x == x + h)
    {
      printf("stepsize underflow in StepperDopr5\n");
      exit(EXIT_FAILURE);
    }
    x+=h;
    h = hNew;    
/*.....................................................................*/

/*...*/
    if(it > IntegralStepMax && fStopIt)
    {
       printf("Numero maximo de passos para integracao alcancado !!\n");
      exit(EXIT_FAILURE);
    }
/*.....................................................................*/

  }while( (x -h) <= x2 );
/*.....................................................................*/

/*...*/
  free(yt);
  free(f);
  free(k4);
  free(k3);
  free(k2);
  free(k1);
/*.....................................................................*/
  if(outCod == FILE_OUT)
    fclose(file);

  return it;
}
/***********************************************************************/

/*********************************************************************
 * Data de criacao    : 16/06/2019                                   *
 * Data de modificaco : 00/00/0000                                   *
 * ------------------------------------------------------------------*
 * stepperDopr853 :  Metodo Runge-kutta explicito de 8 ° ordem como  *
 * passo adaptativo                                                  *
 * ------------------------------------------------------------------*
 * Parametros de entrada:                                            *
 * ------------------------------------------------------------------* 
 * y     -> valores inicial                                          *
 * param -> paramatros utilizado no calculo da funcao f              *
 * x1    -> limite inferio do intervalo de integracao                *
 * x2    -> limite superior do intervalo de integraçao               *
 * hInit -> passo inicial                                            *
 * maxIt -> numero maximo de iteração no processo de integracao      *
 * nEdo  -> numero de edos                                           *
 * maxInt-> numero maximo de passos de integracao                    * 
 * fStopIt -> true para quando maxInt é atingido                     *
 *           false nao a limite de passo de initegra                 *
 * outPut  -> cod de escrita                                         *
 *            1 - tela                                               *
 *            2 - arquivo                                            *
 * fName   -> nomde do aquivo de saida                               *
 * rhs     -> f                                                      *   
 * ------------------------------------------------------------------*
 * Paramanetros de saida:                                            *
 * ------------------------------------------------------------------*
 * ------------------------------------------------------------------*
 * OBS:                                                              *
 * Numerical Recipes webnote No.20, Rv1                              *
 * *******************************************************************/
int stepperDopr853(DOUBLE *y                , DOUBLE *param
                 ,DOUBLE const x1           , DOUBLE const x2
                 ,DOUBLE const hInit        , DOUBLE const aTol 
                 , DOUBLE const rTol        , const short nEdo
                 ,unsigned INT const maxInt , bool const fStopIt
                 ,const short outCod        , const char *const fName
                 ,void (*rhs)())

{

/*...*/
  static DOUBLE c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c14,c15,c16,
              b1,b6,b7,b8,b9,b10,b11,b12,bhh1,bhh2,bhh3,
              er1,er6,er7,er8,er9,er10,er11,er12,
              a21,a31,a32,a41,a43,a51,a53,a54,a61,a64,a65,a71,a74,a75,a76,
              a81,a84,a85,a86,a87,a91,a94,a95,a96,a97,a98,a101,a104,a105,
              a106,a107,a108,a109,a111,a114,a115,a116,a117,a118,a119,a1110,
              a121,a124,a125,a126,a127,a128,a129,a1210,a1211,a141,a147,a148,
              a149,a1410,a1411,a1412,a1413,a151,a156,a157,a158,a1511,a1512,
              a1513,a1514,a161,a166,a167,a168,a169,a1613,a1614,a1615,
              d41,d46,d47,d48,d49,d410,d411,d412,d413,d414,d415,d416,d51,d56,
              d57,d58,d59,d510,d511,d512,d513,d514,d515,d516,d61,d66,d67,d68,
              d69,d610,d611,d612,d613,d614,d615,d616,d71,d76,d77,d78,d79,
              d710,d711,d712,d713,d714,d715,d716;
/*...*/
  FILE *file=NULL;
  short i, iChangeSteps, maxChangeSteps;
  bool lastReject;
  unsigned INT it,IntegralStepMax;
  INT order;
  DOUBLE *k1,*k2,*k3,*k4,*k5,*k6,*k7,*k8,*k9,*k10,*yt;
  DOUBLE x,scale,atol,rtol,deno,err,err2,errOld,safe,hNew
      ,maxScale,minScale,alfa,beta,h,yerr,yerr2;
 
/*... Dormand-Prince*/
/*...*/
  c2 = 0.526001519587677318785587544488e-01;
  c3 = 0.789002279381515978178381316732e-01;
  c4 = 0.118350341907227396726757197510e+00;
  c5 = 0.281649658092772603273242802490e+00;
  c6 = 0.333333333333333333333333333333e+00;
  c7 = 0.25e+00;
  c8 = 0.307692307692307692307692307692e+00;
  c9 = 0.651282051282051282051282051282e+00;
  c10 = 0.6e+00;
  c11 = 0.857142857142857142857142857142e+00;
  c14 = 0.1e+00;
  c15 = 0.2e+00;
  c16 = 0.777777777777777777777777777778e+00;
/*...*/
  b1 = 5.42937341165687622380535766363e-2;
  b6 = 4.45031289275240888144113950566e0;
  b7 = 1.89151789931450038304281599044e0;
  b8 = -5.8012039600105847814672114227e0;
  b9 = 3.1116436695781989440891606237e-1;
  b10 = -1.52160949662516078556178806805e-1;
  b11 = 2.01365400804030348374776537501e-1;
  b12 = 4.47106157277725905176885569043e-2;

/*...*/
  bhh1 = 0.244094488188976377952755905512e+00;
  bhh2 = 0.733846688281611857341361741547e+00;
  bhh3 = 0.220588235294117647058823529412e-01;

/*...*/
  er1  = 0.1312004499419488073250102996e-01;
  er6  = -0.1225156446376204440720569753e+01;
  er7  = -0.4957589496572501915214079952e+00;
  er8  = 0.1664377182454986536961530415e+01;
  er9  = -0.3503288487499736816886487290e+00;
  er10 = 0.3341791187130174790297318841e+00;
  er11 = 0.8192320648511571246570742613e-01;
  er12 = -0.2235530786388629525884427845e-01;

/*...*/
  a21 = 5.26001519587677318785587544488e-2;
  a31 = 1.97250569845378994544595329183e-2;
  a32 = 5.91751709536136983633785987549e-2;
  a41 = 2.95875854768068491816892993775e-2;
  a43 = 8.87627564304205475450678981324e-2;
  a51 = 2.41365134159266685502369798665e-1;
  a53 = -8.84549479328286085344864962717e-1;
  a54 = 9.24834003261792003115737966543e-1;
  a61 = 3.7037037037037037037037037037e-2;
  a64 = 1.70828608729473871279604482173e-1;
  a65 = 1.25467687566822425016691814123e-1;
  a71 = 3.7109375e-2;
  a74 = 1.70252211019544039314978060272e-1;
  a75 = 6.02165389804559606850219397283e-2;
  a76 = -1.7578125e-2;
  a81 = 3.70920001185047927108779319836e-2;
  a84 = 1.70383925712239993810214054705e-1;
  a85 = 1.07262030446373284651809199168e-1;
  a86 = -1.53194377486244017527936158236e-2;
  a87 = 8.27378916381402288758473766002e-3;
  a91 = 6.24110958716075717114429577812e-1;
  a94 = -3.36089262944694129406857109825e0;
  a95 = -8.68219346841726006818189891453e-1;
  a96 = 2.75920996994467083049415600797e1;
  a97 = 2.01540675504778934086186788979e1;
  a98 = -4.34898841810699588477366255144e1;
  a101 = 4.77662536438264365890433908527e-1;
  a104 = -2.48811461997166764192642586468e0;
  a105 = -5.90290826836842996371446475743e-1;
  a106 = 2.12300514481811942347288949897e1;
  a107 = 1.52792336328824235832596922938e1;
  a108 = -3.32882109689848629194453265587e1;
  a109 = -2.03312017085086261358222928593e-2;
  a111 = -9.3714243008598732571704021658e-1;
  a114 = 5.18637242884406370830023853209e0;
  a115 = 1.09143734899672957818500254654e0;
  a116 = -8.14978701074692612513997267357e0;
  a117 = -1.85200656599969598641566180701e1;
  a118 = 2.27394870993505042818970056734e1;
  a119 = 2.49360555267965238987089396762e0;
  a1110 = -3.0467644718982195003823669022e0;
  a121 = 2.27331014751653820792359768449e0;
  a124 = -1.05344954667372501984066689879e1;
  a125 = -2.00087205822486249909675718444e0;
  a126 = -1.79589318631187989172765950534e1;
  a127 = 2.79488845294199600508499808837e1;
  a128 = -2.85899827713502369474065508674e0;
  a129 = -8.87285693353062954433549289258e0;
  a1210 = 1.23605671757943030647266201528e1;
  a1211 = 6.43392746015763530355970484046e-1;
  a141 = 5.61675022830479523392909219681e-2;
  a147 = 2.53500210216624811088794765333e-1;
  a148 = -2.46239037470802489917441475441e-1;
  a149 = -1.24191423263816360469010140626e-1;
  a1410 = 1.5329179827876569731206322685e-1;
  a1411 = 8.20105229563468988491666602057e-3;
  a1412 = 7.56789766054569976138603589584e-3;
  a1413 = -8.298e-3;
  a151 = 3.18346481635021405060768473261e-2;
  a156 = 2.83009096723667755288322961402e-2;
  a157 = 5.35419883074385676223797384372e-2;
  a158 = -5.49237485713909884646569340306e-2;
  a1511 = -1.08347328697249322858509316994e-4;
  a1512 = 3.82571090835658412954920192323e-4;
  a1513 = -3.40465008687404560802977114492e-4;
  a1514 = 1.41312443674632500278074618366e-1;
  a161 = -4.28896301583791923408573538692e-1;
  a166 = -4.69762141536116384314449447206e0;
  a167 = 7.68342119606259904184240953878e0;
  a168 = 4.06898981839711007970213554331e0;
  a169 = 3.56727187455281109270669543021e-1;
  a1613 = -1.39902416515901462129418009734e-3;
  a1614 = 2.9475147891527723389556272149e0;
  a1615 = -9.15095847217987001081870187138e0;
/*...*/
  d41 = -0.84289382761090128651353491142e+01;
  d46 = 0.56671495351937776962531783590e+00;
  d47 = -0.30689499459498916912797304727e+01;
  d48 = 0.23846676565120698287728149680e+01;
  d49 = 0.21170345824450282767155149946e+01;
  d410 = -0.87139158377797299206789907490e+00;
  d411 = 0.22404374302607882758541771650e+01;
  d412 = 0.63157877876946881815570249290e+00;
  d413 = -0.88990336451333310820698117400e-01;
  d414 = 0.18148505520854727256656404962e+02;
  d415 = -0.91946323924783554000451984436e+01;
  d416 = -0.44360363875948939664310572000e+01;
  d51 = 0.10427508642579134603413151009e+02;
  d56 = 0.24228349177525818288430175319e+03;
  d57 = 0.16520045171727028198505394887e+03;
  d58 = -0.37454675472269020279518312152e+03;
  d59 = -0.22113666853125306036270938578e+02;
  d510 = 0.77334326684722638389603898808e+01;
  d511 = -0.30674084731089398182061213626e+02;
  d512 = -0.93321305264302278729567221706e+01;
  d513 = 0.15697238121770843886131091075e+02;
  d514 = -0.31139403219565177677282850411e+02;
  d515 = -0.93529243588444783865713862664e+01;
  d516 = 0.35816841486394083752465898540e+02;
  d61 = 0.19985053242002433820987653617e+02;
  d66 = -0.38703730874935176555105901742e+03;
  d67 = -0.18917813819516756882830838328e+03;
  d68 = 0.52780815920542364900561016686e+03;
  d69 = -0.11573902539959630126141871134e+02;
  d610 = 0.68812326946963000169666922661e+01;
  d611 = -0.10006050966910838403183860980e+01;
  d612 = 0.77771377980534432092869265740e+00;
  d613 = -0.27782057523535084065932004339e+01;
  d614 = -0.60196695231264120758267380846e+02;
  d615 = 0.84320405506677161018159903784e+02;
  d616 = 0.11992291136182789328035130030e+02;
  d71 = -0.25693933462703749003312586129e+02;
  d76 = -0.15418974869023643374053993627e+03;
  d77 = -0.23152937917604549567536039109e+03;
  d78 = 0.35763911791061412378285349910e+03;
  d79 = 0.93405324183624310003907691704e+02;
  d710 = -0.37458323136451633156875139351e+02;
  d711 = 0.10409964950896230045147246184e+03;
  d712 = 0.29840293426660503123344363579e+02;
  d713 = -0.43533456590011143754432175058e+02;
  d714 = 0.96324553959188282948394950600e+02;
  d715 = -0.39177261675615439165231486172e+02;
  d716 = -0.14972683625798562581422125276e+03;
/* ..................................................................*/

 if(outCod == FILE_OUT)
    file = openFile(fName,"w");
/*...*/
  maxChangeSteps  = 100;
  IntegralStepMax = maxInt;
  safe            = 0.9e0;
  atol            = 1.e-3;
  rtol            = 1.e-3;
  maxScale        = 10.e0;
  minScale        = 0.2e0;  
  order           = 8;
  beta            = 0.4/order;
  alfa            = 1.e0/order - 0.75*beta;
/*...................................................................*/

/*...*/
  k1   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k1,"k1");
  k2   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k2,"k2");
  k3   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k3,"k3");
  k4   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k4,"k4");
  k5   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k5,"k5");
  k6   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k6,"k6");
  k7   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k7,"k7");
  k8   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k8,"k8");
  k9   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k9,"k9");
  k10  = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(k10,"k10");
  yt   = (DOUBLE*) malloc(nEdo*sizeof(DOUBLE));
  testAlloc(yt,"yt");
/*...................................................................*/

/*...*/
  h      = hInit;
  it     = 0;
  x      = x1;
  errOld = 1.e0;
/*...................................................................*/

/*...*/
  do
  {
    lastReject   = false;
    iChangeSteps = 0;
    do
    {
/*... k1*/
      rhs(x,y,k1,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*a21*k1[i];
/*.....................................................................*/

/*... k2*/
      rhs(x+c2*h,yt,k2,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a31*k1[i] + a32*k2[i]);
/*.....................................................................*/

/*... k3*/
      rhs(x+c3*h,yt,k3,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a41*k1[i] + a43*k3[i]);  
/*.....................................................................*/
 
/*... k4*/
      rhs(x+c4*h,yt,k4,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a51*k1[i] + a53*k3[i] + a54*k4[i]);
/*.....................................................................*/

/*... k5*/
      rhs(x+c5*h,yt,k5,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a61*k1[i] + a64*k4[i] + a65*k5[i]); 
/*.....................................................................*/

/*... k6*/
      rhs(x+c6*h,yt,k6,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a71*k1[i] + a74*k4[i] + a75*k5[i] + a76*k6[i]);               
/*.....................................................................*/

/*... k7*/
      rhs(x+c7*h,yt,k7,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a81*k1[i] + a84*k4[i] + a85*k5[i] + a86*k6[i] 
                       + a87*k7[i]);               
/*.....................................................................*/

/*... k8*/
      rhs(x+c8*h,yt,k8,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a91*k1[i] + a94*k4[i] + a95*k5[i] + a96*k6[i] 
                       + a97*k7[i] + a98*k8[i] );               
/*.....................................................................*/

/*... k9*/
      rhs(x+c9*h,yt,k9,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a101*k1[i] + a104*k4[i] + a105*k5[i] + a106*k6[i] 
                       + a107*k7[i] + a108*k8[i] + a109*k9[i]);               
/*.....................................................................*/

/*... k10*/
      rhs(x+c10*h,yt,k10,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a111*k1[i] + a114*k4[i] + a115*k5[i] + a116*k6[i] 
                       + a117*k7[i] + a118*k8[i] + a119*k9[i] + a1110*k10[i]);               
/*.....................................................................*/

/*... k11 - reaproveitando k2 como k11*/
      rhs(x+c11*h,yt,k2,param);
      for(i=0;i<nEdo;i++)
        yt[i] = y[i] + h*(a121*k1[i] + a124*k4[i] + a125*k5[i] + a126*k6[i] 
              + a127*k7[i] + a128*k8[i] + a129*k9[i] + a1210*k10[i]
              + a1211*k2[i]);               
/*.....................................................................*/

/*... k12 - reaproveitando k3 como k12*/
      rhs(x+h,yt ,k3,param);          
/*.....................................................................*/

/*...*/
     for(i=0;i<nEdo;i++)
     {
       k4[i] = b1*k1[i]+b6*k6[i]+b7*k7[i]+b8*k8[i]+b9*k9[i]+b10*k10[i]+
               b11*k2[i]+b12*k3[i];
       yt[i]=y[i]+h*k4[i]; 
     }
/*.....................................................................*/

/*...*/
      for(i=0,err=err2=0.e0;i<nEdo;i++)
      {
        scale = atol + max(fabs(y[i]),fabs(yt[i]))*rtol;
/*... Estimativa do error*/
        yerr  =k4[i]-bhh1*k1[i]-bhh2*k9[i]-bhh3*k3[i];
        yerr2 =er1*k1[i]+er6*k6[i]+er7*k7[i]+er8*k8[i]+er9*k9[i]+
                er10*k10[i]+er11*k2[i]+er12*k3[i];

        err2+= (yerr/scale)*(yerr/scale);
        err += (yerr2/scale)*(yerr2/scale);
      }
      deno = err2+0.01*err2;  
      if(deno<= 0.0)
        deno = 1.e0;
      err = fabs(h)*err2*sqrt(1.e0/(nEdo*deno));

/*... passou no controle de erro de trucamento*/
      if( err <= 1.0)
      {
/*...*/
        if(err==0.0)
          scale = maxScale;
        else
        {
          scale =safe*pow(err,-alfa)*pow(errOld,beta);
/*... minScale < hNew/h < maxscale*/
          if( scale > maxScale)
            scale = maxScale;
          else if(scale < minScale)
            scale = minScale;
          }
/*.....................................................................*/

/*... */
          if(lastReject)
            hNew = h*min(scale,1.0);
          else
            hNew = h*scale;
/*.....................................................................*/

          errOld = max(err,1.0e-4);        
          lastReject = false;        
          break;
      }
/*.....................................................................*/

/*...*/
      lastReject = true; 
      scale=max(safe*pow(err,-alfa),minScale);
      h*=scale;
/*.....................................................................*/
      iChangeSteps++;
/*.....................................................................*/
    }while(iChangeSteps < maxChangeSteps);
/*.....................................................................*/

/*...*/
    if(iChangeSteps == maxChangeSteps)
    {
      printf("Numero maximo de mudanca de passo alcancada!!\n");
      exit(EXIT_FAILURE);
    }
/*...................................................................*/


/*...*/
    for(i=0;i<nEdo;i++)
      y[i] = yt[i];
/*.....................................................................*/

/*...*/
     writeOutput(it            , x
                ,h             , y
                ,nEdo          , outCod
                ,file);
/*.....................................................................*/

/*...*/
    it++;
    if ( x == x + h)
    {
      printf("stepsize underflow in StepperDopr853\n");
      exit(EXIT_FAILURE);
    }
    x+=h;
    h = hNew;    
/*.....................................................................*/

/*...*/
    if(it > IntegralStepMax && fStopIt)
    {
       printf("Numero maximo de passos para integracao alcancado !!\n");
      exit(EXIT_FAILURE);
    }
/*.....................................................................*/

  }while( (x -h) <= x2 );
/*.....................................................................*/

/*...*/
  free(yt);
  free(k10);
  free(k9);
  free(k8);
  free(k7);
  free(k6);
  free(k5);
  free(k4);
  free(k3);
  free(k2);
  free(k1);
/*.....................................................................*/

  if(outCod == FILE_OUT)
    fclose(file);

  return it;
}
/***********************************************************************/